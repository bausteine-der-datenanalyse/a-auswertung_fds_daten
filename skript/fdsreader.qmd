# Fdsreader

Um Simulationsdaten, die mit FDS berechnet wurden, mit Python auszuwerten, 
hat die Arbeitsgruppe von Prof. Lukas Arnold das Python-Modul `fdsreader` entwickelt. 
Ziel ist es, die meisten von FDS erzeugten Ausgabeformate auszulesen und 
in Python-Datenstrukturen abzubilden.

Das Modul ist frei verfügbar und Open Source. Der Quellcode ist auf GitHub 
gehostet: [FireDynamics/fdsreader](https://github.com/FireDynamics/fdsreader), 
eine [API-Dokumentation](https://firedynamics.github.io/fdsreader/index.html) 
ist ebenfalls verfügbar.

## Installation und Import des Pakets

Das `fdsreader`-Modul kann über pip installiert werden (siehe auch das GitHub-Repository):

```default
pip install fdsreader
```

Zur Einführung in die grundlegende Verwendung von `fdsreader` betrachten wir 
ein einfaches FDS-Szenario. Zunächst importieren wir das Modul:

```{python}
import fdsreader
```

Da wir die Daten auch visualisieren möchten, importieren wir zusätzlich `matplotlib`:

```{python}
import matplotlib.pyplot as plt
```

## Auswahl des richtigen Ordners

Als Nächstes muss der Reader auf das Verzeichnis zeigen, das die Simulationsdaten enthält, 
insbesondere die Smokeview-Datei:

```{python}
# Pfad zu den Daten definieren
path_to_data = '../skript/01-data/first_example'

sim = fdsreader.Simulation(path_to_data)
```

Das `Simulation`-Objekt `sim` enthält nun alle Informationen und Daten 
des Simulationsausgangs:

```{python}
sim
```

Die Variable `sim` enthält Informationen über das Gitter (`MESH`), vier 
Schnittdaten (`SLCF`) und vier Punktmessungen (`DEVC`). Das zusätzliche 
Messgerät – in der FDS-Eingabedatei wurden nur drei definiert – ist die Zeitspalte.

## Messgeräte-Daten

::: {.callout-tip}
## Messgeräte in FDS
Messgeräte fungieren als virtuelle Sensoren, mit denen Daten wie Temperatur, 
Wärmestrom, Gaskonzentration, Geschwindigkeit usw. an bestimmten Punkten im 
Simulationsbereich aufgezeichnet werden können. Diese Daten sind entscheidend 
für das Verständnis des Verhaltens von Feuer und Rauch unter verschiedenen Bedingungen.

Ein Messgerät kann mit einem Label (`ID`) versehen werden, was die Identifizierung 
in der durch FDS erzeugten CSV-Datei vereinfacht. Es benötigt eine Position 
und eine zu messende Größe.

Positionen können auf verschiedene Arten angegeben werden. Wir fokussieren uns 
hier auf einen Punkt über `XYZ`. Linien, Flächen und Volumen sind jedoch ebenso möglich.

Der Parameter `QUANTITY` erwartet eine Zeichenkette, die angibt, welche Größe 
aufgezeichnet werden soll, z. B. `TEMPERATURE` für die Gastemperatur.
:::

Die einfachste Datenstruktur ist die Ausgabe der `DEVC`-Direktiven. Die verfügbaren 
Daten und Metainformationen können direkt ausgegeben werden:

```{python}
# Kurzreferenz für Bequemlichkeit – `devc` enthält alle Messgeräte
devc = sim.devices
print(devc)
```

Die `Device`-Klasse enthält alle relevanten Informationen (siehe 
[Geräte-Dokumentation](https://firedynamics.github.io/fdsreader/devc.html)):

```{python}
for i in devc:
    print(f"ID: {i.id},\t Messgröße: {i.quantity_name}, \t Position: {i.position}")
```

Einzelne Messgeräte, einschließlich der Zeitspalte, sind über Dictionary-Einträge 
mit ihrer ID als Schlüssel zugänglich. Die Daten eines einzelnen Messgeräts 
(`Device.data`) sind als NumPy-Array gespeichert:

```{python}
type(devc['Temp_Door_Mid'].data)
```

Die Länge entspricht dem erwarteten Wert, also 1801, da die Simulation 1800 s 
dauerte und die Messgeräte jede Sekunde beschrieben wurden, einschließlich `t = 0 s`.

```{python}
len(devc['Time'].data)
```

Ein erster Blick auf die Rohdaten (`Device.data`):

```{python}
devc['Temp_Door_Mid'].data
```

Die Messgerät-Daten können auch mit Matplotlib visualisiert werden:

```{python}
# Plot erstellen
plt.plot(devc['Time'].data, devc['Temp_Door_High'].data)

# Achsen beschriften
plt.xlabel("Zeit / s")
devc_id = devc['Temp_Door_High'].id
devc_q = devc['Temp_Door_High'].quantity_name
devc_u = devc['Temp_Door_High'].unit
plt.ylabel(f"{devc_q} ({devc_id}) / {devc_u}")

# Raster hinzufügen
plt.grid()
```

In gleicher Weise können mehrere Messgeräte gleichzeitig geplottet werden, z. B. 
alle, deren Namen mit `Temp_` beginnen:

```{python}
# Alle Messgeräte durchlaufen
for i in devc:
    
    # Nur Messgeräte mit ID, die mit 'Temp_' beginnt
    if not i.id.startswith('Temp_'): 
        continue
    
    plt.plot(devc["Time"].data, i.data, label=i.id)
    
plt.legend()
plt.xlabel("Zeit / s")
plt.ylabel('Temperatur / $^\circ$C')
plt.grid()
```

## HRR-Daten

::: {.callout-tip}
## Heat Release Rate (HRR)
Ein zentraler Parameter in der Brandmodellierung. Er beschreibt die 
Freisetzungsrate thermischer Energie und wird in Kilowatt (kW) oder 
Megawatt (MW) angegeben.
:::

Wie bei den `DEVC`-Daten kann auch auf die im `HRR`-File gespeicherten 
Daten direkt zugegriffen werden. Diese befinden sich im Attribut `hrr` 
des `Simulation`-Objekts und nicht bei den Messgeräten:

```{python}
plt.plot(sim.hrr['Time'], sim.hrr['HRR'], label='Freisetzung durch Brand')

plt.plot(sim.hrr['Time'], sim.hrr['Q_RADI'], label='Strahlung')
plt.plot(sim.hrr['Time'], sim.hrr['Q_COND'], label='Leitung')
plt.plot(sim.hrr['Time'], sim.hrr['Q_CONV'], label='Konvektion')

plt.plot(sim.hrr['Time'], 
         sim.hrr['HRR'] + sim.hrr['Q_RADI'] + sim.hrr['Q_COND'] + sim.hrr['Q_CONV'], 
         color='grey', label='Summe', zorder=0)

plt.xlabel('Zeit / s')
plt.ylabel('Wärmefreisetzung / kW')
plt.legend()
plt.grid()
```

## Slice-Daten

::: {.callout-tip}
## Slices
Slices sind eine Art der Ausgabe, bei der bestimmte physikalische Größen 
(z. B. Temperatur, Geschwindigkeit, Rauchkonzentration) innerhalb einer Ebene 
des Simulationsraums visualisiert werden können. Diese Schnitte geben einen 
Einblick, wie sich Größen über einen Bereich verteilen.
:::

Die durch `SLCF` erzeugten Daten erstrecken sich über zwei oder drei 
räumliche Dimensionen sowie über die Zeit. Zusätzlich können sie auf mehrere 
Meshes verteilt sein.

Die Slice-Daten werden pro Mesh gespeichert. In diesem Beispiel gibt es nur 
ein Mesh, doch der Zugriff erfolgt trotzdem formell mit Index.

Die Datenstruktur sieht wie folgt aus:

```{python}
#| eval: false
#| echo: true
sim.slices[sliceid][meshid].data[zeitindex, richtung1, richtung2]
```

Dabei ist `sliceid` der Index des Slices, `meshid` der Mesh-Index 
(hier: 0), und der Zugriff erfolgt über den Zeitindex sowie zwei 
Raumrichtungen (für 2D-Slices).

Es gibt mehrere Slice-Objekte:

```{python}
# Verfügbare Slices ausgeben
for slice in sim.slices:
    print(f"Slicetyp [2D/3D]: {slice.type}\n  Größe: {slice.quantity.name}\n", 
          f" Ausdehnung: {slice.extent}\n  Orientierung [1/2/3]: {slice.orientation}\n")
```

Es gibt viele Wege einen bestimmten Slice unter den anderen zu finden. 
Eine Möglichkeit, den gewünschten Slice zu finden, ist das Filtern 
nach Quantity über `filter_by_quantity`:

```{python}
# Slice(s) mit W-Geschwindigkeit bekommen
w_slice = sim.slices.filter_by_quantity("W-VELOCITY")
print(w_slice)
```

Oder die Auswahl über die Nähe zu einem Punkt:

```{python}
# Auswahl basierend auf der Nähe zu einem Punkt
slc = w_slice.get_nearest(x=1, z=2)
print(slc)
```

Der Zugriff auf Slice-Daten benötigt die Auswahl von einem bestimmten Mesh und Zeitindex. Die 
Funktion `get_nearest_timestep` hilft dabei:

```{python}
# Zeitindex nahe t=25 s auswählen
it = slc.get_nearest_timestep(25)
print(f"Zeitschritt: {it}")
print(f"Simulationszeit: {slc.times[it]}")
```

Das folgende Beispiel zeigt eine Darstellung der Daten und die benötigten Schritte um diese anzupassen. Die Anpassungen finden anhand der Datenausrichtung aus der Function `imshow` statt.

```{python}
# Temperaturslice in y-Richtung auswählen
slc = sim.slices.filter_by_quantity('TEMPERATURE').get_nearest(x=3, y=0)
print(slc)
# Nur ein Mesh
slc_data = slc[0].data
print(slc_data)
```

```{python}
# Erste Visualisierung bei t=50 s
it = slc.get_nearest_timestep(50)
plt.imshow(slc_data[it])
```

```{python}
# Auf transponierte Darstellung mithilfe von ndarray.T zugreifen und anpassung des Ursprungs
plt.imshow(slc_data[it].T, origin='lower')
```

```{python}
# Erste Visualisierung bei t=50 s
# Angabe der Ausdehnung um von Indexen in den physikalischen Raum zu wechseln
# Festsetzen eines Maximalwerts mit Hilfe von vmax

plt.imshow(slc_data[it].T, 
           origin='lower',
           vmax=200,
           extent=slc.extent.as_list())
plt.colorbar(label='Temperatur / °C', orientation='horizontal')
plt.xlabel('x-Koordinate / m')
plt.ylabel('z-Koordinate / m')
```

```{python}
# Beispiel für Mehrfach-Plot
list_t = [0, 50, 100, 200, 300, 400]
fig, axs = plt.subplots(2,3, sharex=True, sharey=True)
for i in range(len(list_t)):
    it = slc.get_nearest_timestep(list_t[i])
    axs.flat[i].imshow(slc_data[it].T,
                       vmin=20,
                       vmax=400,
                       origin='lower', 
                       extent=slc.extent.as_list())
    axs.flat[i].set_title(f"t={slc.times[it]:.1f}")
```
